## 构成要素
标识符(identifier)  关键字(keyword)  字面量(literal)  操作符(opetator)  分隔符(delimiter)

## 基本数据类型
bool  byte  rune  int  float32  complex32 string
## 高级数据类型
array  slice  map  struct  interface
## 流程控制语句
if  switch  for defer

数据类型

new    make
new
  用来分配内存的内建函数，但是不像在其它语言中，它并不初始化内存，只是将其置零。也就是说，new(T)会为T类型的新项目，分配被置零的存储，并且返回它的地址，一个类型为*T的值
  
make
  它只用来创建slice，map和channel，并且返回一个初始化的(而不是置零)，类型为T的值

append
  func append(slice []T, elements ...T) []T

bool

string
要修改字符串，可先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组
for i := 0; i < len(s); i++ { // byte类型
for _, r := range s {         // rune类型

int   init8   int16   int32   int64

uint uint8  uint16  uint32  uint64  uintptr

byte //uint8的别名   rune //int32的别名,专门用于存储unicode编码的单个字符

float32   float64

complex64   complex128

数组  切片slice    映射
数组
  具有相同唯一类型的一组已编号且长度固定的数据项序列
  元素可通过索引(位置)读取或修改。索引从0开始
  
格式
  var identifier [len]type
  
数组是一种值类型，可以通过new()创建   
    var arr1=new([5]int)    类型是*[5]int
    var arr2 [5]int         类型是[5]int
    [...]int{}    

多维数组
var array [][][]type


指针数组[n]*T，数组指针 *[n]T





切片slice
make([]type,len,cap)
[]type{value,...}
var slice []type

创建slice的3个索引
slice2:=slice1[start:len:cap]

append(slice,value)
append(slice1,slice2...)	...可以将一个切片的所有元素追加到另一个切片

copy


迭代slice
for index,value:=range slice {}
range返回两个值，一个迭代的索引位置，一个索引值的副本
迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以value 的地址总是相同的


多维切片
[][]type{{value,value},...}




## 映射map
用于存储一系列无序的键值对的无序集合
创建map
var map map[type]type

ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
相当于
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34

删除元素
delete(ages, "alice")

结构体
struct

引用类型
切片slice	映射map 		通道		接口		函数

结构类型


指针
支持指针类型 *T，指针的指针 **T，以及包含包名前缀的 *<package>.T
"&"操作符取变量地址，
"*"透过指针访问⺫标对象

自定义类型
typr newtype currenttype
新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息





接口(interface)


通道(channel)


```golang
var val0 string
fmt.Println(reflect.TypeOf(val0), unsafe.Sizeof(val0), val0)
// string 16

var val1 = "A"
fmt.Println(reflect.TypeOf(val1), unsafe.Sizeof(val1), val1)
// string 16 A

var data1 = struct{}{}
fmt.Println(reflect.TypeOf(data1), unsafe.Sizeof(data1), data1)
// struct {} 0 {}
```

ASCII table
![此处输入图片的描述ASCII table][1]

[1]: https://github.com/gyuho/learn/raw/master/doc/go_character_string/img/ascii.png

string
字符串是bytes序列的集合

```
fmt.Println("\\") // \
fmt.Println(`\\`) // \\
```


>mutable bytes and rune, immutable string
```go
func main() {
	bts := []byte("Hello")
	bts[0] = byte(100)
	for _, c := range bts {
		fmt.Println(string(c), c)
	}
	/*
	   d 100
	   e 101
	   l 108
	   l 108
	   o 111
	*/

	rs := []rune("Hello")
	rs[0] = rune(100)
	for _, c := range rs {
		fmt.Println(string(c), c)
	}
	/*
	   d 100
	   e 101
	   l 108
	   l 108
	   o 111
	*/

	str := "Hello"
	// str[0] = byte(100)
	// cannot assign to str[0]
	for _, c := range str {
		fmt.Println(string(c), c)
	}
	/*
	   H 72
	   e 101
	   l 108
	   l 108
	   o 111
	*/
}
```

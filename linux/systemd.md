# systemd 

## systemd架构  
[systemd架构 ](https://images2018.cnblogs.com/blog/952033/201802/952033-20180222132628193-51070473.png)


unit(单元)  
service ：代表一个后台服务进程，比如 mysqld。这是最常用的一类  
socket ：此类配置单元封装系统和互联网中的一个套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个"连接"进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)  
device ：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现  
mount ：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将 /etc/fstab 中的条目都转换为挂载点，并在开机时处理  
automount ：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为  
swap：和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活  
target ：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5)  
timer：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务  
snapshot ：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态  
path：文件系统中的一个文件或目录  
scope：用于 cgroups，表示从 systemd 外部创建的进程  
slice：用于 cgroups，表示一组按层级排列的单位。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中  


## 服务类型unit  
服务类型unit分三部分[Unit]--[Service]--[Install]  

### [Unit]  
Description   关于此unit的说明  
Documentation   文档相关内容  
After        说明此unit是在哪个服务启动之后才启动的意思.仅说明服务启动的顺序,没有强制要求  
Before       与After的意义相反，在指定的服务启动前最好启动本个服务的意思。仅是说明服务启动的顺序而已，并没有强制要求  
Requires     本unit需要在哪个服务启动后才能够启动！就是设置服务间的依赖性。如果在此项设置的前导服务没有启动成功，那么本 unit 就不会被启动  
Wants        与Requires刚好相反，规范的是这个unit之后还要启动什么服务，如果Wants后面接的服务没有启动成功，其实不会影响到unit本身  
Conflicts    这个项目后面接的服务如果有启动，那么本unit就不启动！如果unit启动了，则指定的服务就不能启动  

## [Service]  
Type        说明服务的启动方式，会影响到ExecStart，主要有下面几种类型：  
        simple：默认值，这个服务主要由 ExecStart 设置的程序来启动，启动后常驻于内存中。
        forking：由 ExecStart 指定的启动的程序通过 spawns 产生子进程提供服务，然后父进程退出。
        oneshot：与 simple 类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中。
        dbus：与 simple 类似，但这个服务必须要在取得一个 D-Bus 的名称后，才会继续运行！因此设置这个项目时，通常也要设置 BusName= 才行。
        idle：与 simple 类似，意思是，要执行这个服务必须要所有的工作都顺利执行完毕后才会执行。这类的服务通常是开机到最后才执行即可的服务。
        notify：与 simple 类似，但这个服务必须要收到一个 sd_notify() 函数发送的消息后，才会继续运行  
ExecStart

